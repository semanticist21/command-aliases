# Tauri + Swift + macOS App Store ÌÜµÌï© Ìå®ÌÑ¥ Í∞ÄÏù¥Îìú

> **ÌîÑÎ°úÏ†ùÌä∏**: AnyImage Converter
> **Î™©Ï†Å**: Îã§Î•∏ Tauri ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Swift ÌÜµÌï© Î∞è App Store Î∞∞Ìè¨ Ìå®ÌÑ¥

---

## Î™©Ï∞®

1. [Swift ÌÜµÌï© Ìå®ÌÑ¥](#1-swift-ÌÜµÌï©-Ìå®ÌÑ¥)
2. [In-App Purchase (IAP) Íµ¨ÌòÑ](#2-in-app-purchase-iap-Íµ¨ÌòÑ)
3. [macOS App Store ÏΩîÎìú ÏÑúÎ™Ö](#3-macos-app-store-ÏΩîÎìú-ÏÑúÎ™Ö)
4. [ÎîîÏûêÏù∏ ÏãúÏä§ÌÖú Ìå®ÌÑ¥](#4-ÎîîÏûêÏù∏-ÏãúÏä§ÌÖú-Ìå®ÌÑ¥)

---

## 1. Swift ÌÜµÌï© Ìå®ÌÑ¥

TauriÏóêÏÑú SwiftÎ•º ÏÇ¨Ïö©ÌïòÎäî Î∞©Î≤ïÏùÄ **2Í∞ÄÏßÄ**ÏûÖÎãàÎã§:

### 1.1 Swift Sidecar (CLI ÌîÑÎ°úÏÑ∏Ïä§)

**ÏÇ¨Ïö© ÏãúÍ∏∞**: macOS ÎÑ§Ïù¥Ìã∞Î∏å APIÎ•º ÎπÑÎèôÍ∏∞Ï†ÅÏúºÎ°ú Ìò∏Ï∂úÌïòÍ≥†, ÌîÑÎ°úÏÑ∏Ïä§ Í≤©Î¶¨Í∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞

**Ïû•Ï†ê**:
- ‚úÖ ÎèÖÎ¶Ω Ïã§Ìñâ ÌååÏùºÎ°ú Ïï±Í≥º Í≤©Î¶¨
- ‚úÖ JSON ÌÜµÏã†ÏúºÎ°ú Í∞ÑÎã®Ìïú Îç∞Ïù¥ÌÑ∞ ÍµêÌôò
- ‚úÖ ÌÅ¨ÎûòÏãú Ïãú Ïï± Ï†ÑÏ≤¥ ÏòÅÌñ• ÏóÜÏùå

**Îã®Ï†ê**:
- ‚ùå GUI Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú Î∂àÍ∞Ä (Î∞±Í∑∏ÎùºÏö¥Îìú ÌîÑÎ°úÏÑ∏Ïä§)
- ‚ùå ÌîÑÎ°úÏÑ∏Ïä§ Ïã§Ìñâ Ïò§Î≤ÑÌó§Îìú

#### 1.1.1 Swift Sidecar Íµ¨ÌòÑ (heic-sidecar ÏòàÏãú)

**Swift CLI ÏΩîÎìú** (`src-tauri/sidecars/heic-sidecar.swift`):

```swift
#!/usr/bin/env swift

import Foundation
import ImageIO
import UniformTypeIdentifiers
import CoreGraphics

// JSON ÏùëÎãµ Íµ¨Ï°∞Ï≤¥
struct Response: Codable {
    let success: Bool
    let message: String?
    let data: String?   // base64 Ïù∏ÏΩîÎî© Îç∞Ïù¥ÌÑ∞ (ÏÑ†ÌÉù)
    let error: String?
}

// HEIC ÎîîÏΩîÎî© Ìï®Ïàò
func decodeHEIC(inputPath: String, outputFormat: String, outputPath: String?) -> Response {
    guard let imageSource = CGImageSourceCreateWithURL(
        URL(fileURLWithPath: inputPath) as CFURL, nil
    ) else {
        return Response(success: false, message: nil, data: nil,
                       error: "Failed to read HEIC file")
    }

    // Ìè¨Îß∑ Í≤∞Ï†ï
    let utType: CFString = outputFormat.lowercased() == "png"
        ? UTType.png.identifier as CFString
        : UTType.jpeg.identifier as CFString

    // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î≥¥Ï°¥
    let sourceProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any] ?? [:]
    var filteredProperties: [CFString: Any] = [:]

    let validKeys: [CFString] = [
        kCGImagePropertyTIFFDictionary,
        kCGImagePropertyExifDictionary,
        kCGImagePropertyGPSDictionary,
        // ... Í∏∞ÌÉÄ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌÇ§
    ]

    for key in validKeys {
        if let value = sourceProperties[key] {
            filteredProperties[key] = value
        }
    }

    // ÌååÏùº Ïì∞Í∏∞
    guard let destination = CGImageDestinationCreateWithURL(
        URL(fileURLWithPath: outputPath!) as CFURL, utType, 1, nil
    ) else {
        return Response(success: false, message: nil, data: nil,
                       error: "Failed to create output file")
    }

    CGImageDestinationAddImageFromSource(destination, imageSource, 0,
                                        filteredProperties as CFDictionary)

    guard CGImageDestinationFinalize(destination) else {
        return Response(success: false, message: nil, data: nil,
                       error: "Failed to write output file")
    }

    return Response(success: true, message: "HEIC decoded successfully",
                   data: nil, error: nil)
}

// JSON Ï∂úÎ†• Ìï®Ïàò
func printJSON(_ response: Response) {
    if let jsonData = try? JSONEncoder().encode(response),
       let jsonString = String(data: jsonData, encoding: .utf8) {
        print(jsonString)  // stdoutÎ°ú JSON Ï∂úÎ†•
    }
}

// CLI ÏßÑÏûÖÏ†ê
func main() {
    let args = CommandLine.arguments

    guard args.count >= 4 else {
        printJSON(Response(success: false, message: nil, data: nil,
                          error: "Usage: heic-sidecar decode <input> <format> <output>"))
        exit(1)
    }

    let action = args[1]
    let inputPath = args[2]
    let format = args[3]
    let outputPath = args[4]

    let response = decodeHEIC(inputPath: inputPath, outputFormat: format,
                             outputPath: outputPath)
    printJSON(response)
    exit(response.success ? 0 : 1)
}

main()
```

**Rust ÌÜµÏã† Î†àÏù¥Ïñ¥** (`src-tauri/src/heic.rs`):

```rust
use serde::{Deserialize, Serialize};
use tauri_plugin_shell::ShellExt;

#[derive(Debug, Serialize, Deserialize)]
pub struct HeicResponse {
    pub success: bool,
    pub message: Option<String>,
    pub data: Option<String>,
    pub error: Option<String>,
}

/// HEIC ÌååÏùºÏùÑ PNG/JPEGÎ°ú ÎîîÏΩîÎî©
pub async fn decode_heic(
    app: tauri::AppHandle,
    input_path: &str,
    output_path: &str,
    format: &str,
) -> Result<(), String> {
    // Sidecar Ïã§Ìñâ (tauri-plugin-shell ÏÇ¨Ïö©)
    let output = app
        .shell()
        .sidecar("heic-sidecar")  // tauri.conf.jsonÏóê Îì±Î°ùÎêú Ïù¥Î¶Ñ
        .map_err(|e| format!("Failed to create heic-sidecar: {}", e))?
        .args(["decode", input_path, format, output_path])
        .output()
        .await
        .map_err(|e| format!("Failed to execute heic-sidecar: {}", e))?;

    // JSON ÏùëÎãµ ÌååÏã±
    let response: HeicResponse = serde_json::from_slice(&output.stdout)
        .map_err(|e| format!("Failed to parse response: {}", e))?;

    if let Some(error) = response.error {
        return Err(error);
    }

    Ok(())
}
```

**Tauri ÏÑ§Ï†ï** (`src-tauri/tauri.conf.json`):

```json
{
  "bundle": {
    "externalBin": [
      "sidecars/heic-sidecar"
    ]
  }
}
```

**ÎπåÎìú Ïä§ÌÅ¨Î¶ΩÌä∏** (`scripts/build-sidecars.sh`):

```bash
#!/bin/bash
set -e

cd src-tauri/sidecars

echo "üî® Building heic-sidecar..."
swiftc -target aarch64-apple-macosx12.0 \
  heic-sidecar.swift \
  -o heic-sidecar-aarch64-apple-darwin

echo "‚úÖ heic-sidecar built successfully"
```

**ReactÏóêÏÑú Ìò∏Ï∂ú**:

```typescript
import { invoke } from "@tauri-apps/api/core";

// Tauri commandÎ°ú ÎûòÌïëÎêú Ìï®Ïàò Ìò∏Ï∂ú
await invoke("convert_heic_to_png", {
  inputPath: "/path/to/image.heic",
  outputPath: "/path/to/output.png"
});
```

---

### 1.2 Swift Static Library (FFI)

**ÏÇ¨Ïö© ÏãúÍ∏∞**: GUI Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú, Ïï± ÌîÑÎ°úÏÑ∏Ïä§ ÎÇ¥ÏóêÏÑú ÎèôÍ∏∞ Ïã§ÌñâÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞

**Ïû•Ï†ê**:
- ‚úÖ GUI Ïª®ÌÖçÏä§Ìä∏ Ïú†ÏßÄ (ÏãúÏä§ÌÖú Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú Í∞ÄÎä•)
- ‚úÖ FFI Ìò∏Ï∂úÎ°ú Îπ†Î•∏ Ïã§Ìñâ
- ‚úÖ StoreKit IAP Í∞ôÏùÄ GUI Í∏∞Î∞ò API ÏÇ¨Ïö© Í∞ÄÎä•

**Îã®Ï†ê**:
- ‚ùå Ïï± Î∞îÏù¥ÎÑàÎ¶¨Ïóê Ìè¨Ìï®ÎêòÏñ¥ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
- ‚ùå ÌÅ¨ÎûòÏãú Ïãú Ïï± Ï†ÑÏ≤¥ ÏòÅÌñ•

#### 1.2.1 Swift Static Library Íµ¨ÌòÑ (IAP ÏòàÏãú)

**Swift Static Library ÏΩîÎìú** (`src-tauri/swift/iap-lib.swift`):

```swift
import Foundation
import StoreKit

// C Ìò∏Ìôò Ìï®Ïàò (extern "C")
@_cdecl("iap_check_pro_status")
public func iap_check_pro_status() -> Bool {
    // UserDefaultsÏóêÏÑú Íµ¨Îß§ ÏÉÅÌÉú ÌôïÏù∏
    return UserDefaults.standard.bool(forKey: "isPro")
}

@_cdecl("iap_purchase_pro_mode")
public func iap_purchase_pro_mode() -> Bool {
    // StoreKit Íµ¨Îß§ ÌîåÎ°úÏö∞ Ïã§Ìñâ (ÎèôÍ∏∞Ìôî)
    let semaphore = DispatchSemaphore(value: 0)
    var success = false

    Task {
        do {
            let product = try await Product.products(for: ["com.example.pro"]).first
            let result = try await product?.purchase()

            switch result {
            case .success(let verification):
                // Íµ¨Îß§ ÏÑ±Í≥µ
                UserDefaults.standard.set(true, forKey: "isPro")
                success = true
            default:
                success = false
            }
        } catch {
            success = false
        }
        semaphore.signal()
    }

    semaphore.wait()
    return success
}

@_cdecl("iap_get_product_info")
public func iap_get_product_info() -> UnsafeMutablePointer<CChar>? {
    let semaphore = DispatchSemaphore(value: 0)
    var jsonString = ""

    Task {
        do {
            let product = try await Product.products(for: ["com.example.pro"]).first

            let response = [
                "id": product?.id ?? "",
                "name": product?.displayName ?? "",
                "price": product?.displayPrice ?? ""
            ]

            let jsonData = try JSONSerialization.data(withJSONObject: response)
            jsonString = String(data: jsonData, encoding: .utf8) ?? ""
        } catch {
            jsonString = "{\"error\": \"Failed to load product\"}"
        }
        semaphore.signal()
    }

    semaphore.wait()
    return strdup(jsonString)  // RustÏóêÏÑú Ìï¥Ï†ú ÌïÑÏöî
}

@_cdecl("iap_free_string")
public func iap_free_string(_ ptr: UnsafeMutablePointer<CChar>?) {
    free(ptr)
}
```

**Rust FFI Î∞îÏù∏Îî©** (`src-tauri/src/iap.rs`):

```rust
use serde::{Deserialize, Serialize};
use std::ffi::CStr;
use std::os::raw::c_char;

// C Ìï®Ïàò ÏÑ†Ïñ∏ (Swift static libraryÏóêÏÑú Ï†úÍ≥µ)
extern "C" {
    fn iap_check_pro_status() -> bool;
    fn iap_purchase_pro_mode() -> bool;
    fn iap_restore_purchases() -> bool;
    fn iap_get_product_info() -> *mut c_char;
    fn iap_free_string(ptr: *mut c_char);
}

#[derive(Debug, Serialize, Deserialize)]
pub struct IAPResponse {
    pub id: Option<String>,
    pub name: Option<String>,
    pub price: Option<String>,
    pub error: Option<String>,
}

/// Pro Î™®Îìú Íµ¨Îß§ ÏÉÅÌÉú ÌôïÏù∏
#[tauri::command]
pub async fn check_pro_status() -> Result<bool, String> {
    let is_pro = unsafe { iap_check_pro_status() };
    Ok(is_pro)
}

/// Pro Î™®Îìú Íµ¨Îß§
#[tauri::command]
pub async fn purchase_pro_mode() -> Result<bool, String> {
    let success = unsafe { iap_purchase_pro_mode() };
    Ok(success)
}

/// Ï†úÌíà Ï†ïÎ≥¥ Ï°∞Ìöå
#[tauri::command]
pub async fn get_product_info() -> Result<IAPResponse, String> {
    unsafe {
        let c_str_ptr = iap_get_product_info();
        if c_str_ptr.is_null() {
            return Err("Failed to get product info".to_string());
        }

        let c_str = CStr::from_ptr(c_str_ptr);
        let json_str = c_str
            .to_str()
            .map_err(|e| format!("UTF-8 conversion error: {}", e))?;

        let response: IAPResponse = serde_json::from_str(json_str)
            .map_err(|e| format!("JSON parse error: {}", e))?;

        // SwiftÏóêÏÑú Ìï†ÎãπÌïú Î©îÎ™®Î¶¨ Ìï¥Ï†ú
        iap_free_string(c_str_ptr);

        Ok(response)
    }
}
```

**Cargo ÎπåÎìú ÏÑ§Ï†ï** (`src-tauri/Cargo.toml`):

```toml
[build-dependencies]
tauri-build = { version = "2", features = [] }

[target.'cfg(target_os = "macos")'.dependencies]
# No additional deps needed - static library linked via build.rs
```

**ÎπåÎìú Ïä§ÌÅ¨Î¶ΩÌä∏** (`src-tauri/build.rs`):

```rust
fn main() {
    #[cfg(target_os = "macos")]
    {
        // Swift static library ÎßÅÌÅ¨
        println!("cargo:rustc-link-search=native=target/aarch64-apple-darwin/release");
        println!("cargo:rustc-link-lib=static=iap");

        // Swift Îü∞ÌÉÄÏûÑ ÌîÑÎ†àÏûÑÏõåÌÅ¨ ÎßÅÌÅ¨
        println!("cargo:rustc-link-lib=framework=Foundation");
        println!("cargo:rustc-link-lib=framework=StoreKit");
    }

    tauri_build::build()
}
```

**Static Library ÎπåÎìú Ïä§ÌÅ¨Î¶ΩÌä∏** (`scripts/build-iap-lib.sh`):

```bash
#!/bin/bash
set -e

SWIFT_DIR="src-tauri/swift"
OUTPUT_DIR="src-tauri/target"

# ÌÉÄÍ≤ü ÏïÑÌÇ§ÌÖçÏ≤ò Í≤∞Ï†ï
ARCH=$(uname -m)
if [ "$ARCH" = "arm64" ]; then
    TARGET="aarch64-apple-darwin"
else
    TARGET="x86_64-apple-darwin"
fi

# Swift Ïª¥ÌååÏùº ÌîåÎûòÍ∑∏
SWIFT_FLAGS="-sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"
SWIFT_FLAGS="$SWIFT_FLAGS -target $TARGET"
SWIFT_FLAGS="$SWIFT_FLAGS -O"  # ÏµúÏ†ÅÌôî

# Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
mkdir -p "$OUTPUT_DIR/$TARGET/release"

# Swift ‚Üí Object ÌååÏùº
echo "üî® Compiling iap-lib.swift..."
swiftc $SWIFT_FLAGS \
    -c "$SWIFT_DIR/iap-lib.swift" \
    -o "$OUTPUT_DIR/iap-lib.o"

# Static Library ÏÉùÏÑ±
echo "üì¶ Creating static library libiap.a..."
ar rcs "$OUTPUT_DIR/$TARGET/release/libiap.a" "$OUTPUT_DIR/iap-lib.o"

# Object ÌååÏùº Ï†ïÎ¶¨
rm "$OUTPUT_DIR/iap-lib.o"

echo "‚úÖ IAP static library built successfully!"
```

**ReactÏóêÏÑú Ìò∏Ï∂ú**:

```typescript
import { invoke } from "@tauri-apps/api/core";

// Pro Î™®Îìú ÌôïÏù∏
const isPro = await invoke<boolean>("check_pro_status");

// Íµ¨Îß§ Ïã§Ìñâ (StoreKit Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú)
const success = await invoke<boolean>("purchase_pro_mode");

// Ï†úÌíà Ï†ïÎ≥¥ Ï°∞Ìöå
const productInfo = await invoke<IAPResponse>("get_product_info");
```

---

### 1.3 Swift ÌÜµÌï© Ìå®ÌÑ¥ ÎπÑÍµêÌëú

| Ìï≠Î™© | Sidecar (CLI) | Static Library (FFI) |
|------|---------------|----------------------|
| **ÌÜµÏã† Î∞©Ïãù** | JSON (stdout) | C FFI Ìï®Ïàò Ìò∏Ï∂ú |
| **ÌîÑÎ°úÏÑ∏Ïä§** | ÎèÖÎ¶Ω Ïã§Ìñâ ÌååÏùº | Ïï± Î∞îÏù¥ÎÑàÎ¶¨ ÎÇ¥Ïû• |
| **GUI ÏßÄÏõê** | ‚ùå Î∂àÍ∞Ä (Î∞±Í∑∏ÎùºÏö¥Îìú) | ‚úÖ Í∞ÄÎä• (Ïï± Ïª®ÌÖçÏä§Ìä∏) |
| **ÏÜçÎèÑ** | ÎäêÎ¶º (ÌîÑÎ°úÏÑ∏Ïä§ ÏÉùÏÑ±) | Îπ†Î¶Ñ (ÏßÅÏ†ë Ìò∏Ï∂ú) |
| **ÌÅ¨ÎûòÏãú Í≤©Î¶¨** | ‚úÖ Ïï± ÏòÅÌñ• ÏóÜÏùå | ‚ùå Ïï± Ï†ÑÏ≤¥ ÌÅ¨ÎûòÏãú |
| **ÎπåÎìú ÏÇ∞Ï∂úÎ¨º** | Î≥ÑÎèÑ Î∞îÏù¥ÎÑàÎ¶¨ | .a ÌååÏùº (Ïï±Ïóê ÎßÅÌÅ¨) |
| **ÏΩîÎìú ÏÑúÎ™Ö** | Í∞úÎ≥Ñ ÏÑúÎ™Ö ÌïÑÏöî | Ïï±Í≥º Ìï®Íªò ÏÑúÎ™Ö |
| **ÏÇ¨Ïö© ÏòàÏãú** | HEIC Î≥ÄÌôò, Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ | IAP, ÏãúÏä§ÌÖú Í∂åÌïú ÏöîÏ≤≠ |

---

## 2. In-App Purchase (IAP) Íµ¨ÌòÑ

### 2.1 StoreKit 2 ÌÜµÌï© (Swift Static Library)

**Ï†úÌíà ID ÏÑ§Ï†ï** (App Store Connect):
- Ï†úÌíà ID: `com.yourapp.pro`
- Ïú†Ìòï: Non-Consumable (ÏòÅÍµ¨ Íµ¨Îß§)

**Swift Íµ¨ÌòÑ Ìå®ÌÑ¥**:

```swift
import StoreKit

// 1. Ï†úÌíà Î°úÎìú
let products = try await Product.products(for: ["com.yourapp.pro"])
let proProduct = products.first

// 2. Íµ¨Îß§ Ïã§Ìñâ
let result = try await proProduct.purchase()

switch result {
case .success(let verification):
    // Íµ¨Îß§ Í≤ÄÏ¶ù
    switch verification {
    case .verified(let transaction):
        // ‚úÖ Ï†ïÏÉÅ Íµ¨Îß§
        await transaction.finish()
        UserDefaults.standard.set(true, forKey: "isPro")

    case .unverified(_, let error):
        // ‚ùå Í≤ÄÏ¶ù Ïã§Ìå®
        print("Verification failed: \(error)")
    }

case .userCancelled:
    // ÏÇ¨Ïö©Ïûê Ï∑®ÏÜå
    return false

case .pending:
    // Íµ¨Îß§ ÎåÄÍ∏∞ Ï§ë (Í∞ÄÏ°± Í≥µÏú† ÏäπÏù∏ Îì±)
    return false

@unknown default:
    return false
}

// 3. Íµ¨Îß§ Î≥µÏõê
for await result in Transaction.currentEntitlements {
    if case .verified(let transaction) = result {
        if transaction.productID == "com.yourapp.pro" {
            UserDefaults.standard.set(true, forKey: "isPro")
            await transaction.finish()
        }
    }
}
```

### 2.2 Pro Mode ÏÉÅÌÉú Í¥ÄÎ¶¨ (React + Zustand)

**Zustand Store** (`src/stores/pro-mode-store.ts`):

```typescript
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { invoke } from "@tauri-apps/api/core";

interface ProModeStore {
  isPro: boolean;
  isLoading: boolean;
  checkProStatus: () => Promise<void>;
  purchaseProMode: () => Promise<boolean>;
  restorePurchases: () => Promise<boolean>;
}

export const useProModeStore = create<ProModeStore>()(
  persist(
    (set, get) => ({
      isPro: false,
      isLoading: false,

      checkProStatus: async () => {
        set({ isLoading: true });
        try {
          const isPro = await invoke<boolean>("check_pro_status");
          set({ isPro, isLoading: false });
        } catch (error) {
          console.error("Failed to check pro status:", error);
          set({ isLoading: false });
        }
      },

      purchaseProMode: async () => {
        set({ isLoading: true });
        try {
          const success = await invoke<boolean>("purchase_pro_mode");
          if (success) {
            set({ isPro: true, isLoading: false });
          } else {
            set({ isLoading: false });
          }
          return success;
        } catch (error) {
          console.error("Purchase failed:", error);
          set({ isLoading: false });
          return false;
        }
      },

      restorePurchases: async () => {
        set({ isLoading: true });
        try {
          const isPro = await invoke<boolean>("restore_purchases");
          set({ isPro, isLoading: false });
          return isPro;
        } catch (error) {
          console.error("Restore failed:", error);
          set({ isLoading: false });
          return false;
        }
      },
    }),
    {
      name: "pro-mode-storage",  // localStorage ÌÇ§
      partialize: (state) => ({ isPro: state.isPro }),  // isProÎßå Ï†ÄÏû•
    }
  )
);
```

**Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏÇ¨Ïö©**:

```typescript
import { useProModeStore } from "@/stores/pro-mode-store";

function App() {
  const { isPro, isLoading, checkProStatus, purchaseProMode } = useProModeStore();

  useEffect(() => {
    // Ïï± ÏãúÏûë Ïãú Pro ÏÉÅÌÉú ÌôïÏù∏
    checkProStatus();
  }, []);

  const handlePurchase = async () => {
    const success = await purchaseProMode();
    if (success) {
      toast.success("Pro Mode Íµ¨Îß§ ÏôÑÎ£å!");
    } else {
      toast.error("Íµ¨Îß§Í∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.");
    }
  };

  return (
    <div>
      {isPro ? (
        <Badge>Pro Mode</Badge>
      ) : (
        <Button onClick={handlePurchase} disabled={isLoading}>
          {isLoading ? "Ï≤òÎ¶¨ Ï§ë..." : "Pro Mode Íµ¨Îß§"}
        </Button>
      )}
    </div>
  );
}
```

### 2.3 ÌååÏùº Ï†úÌïú Î°úÏßÅ (Pro Mode)

**Tauri CommandÏóêÏÑú Ï†úÌïú Ï†ÅÏö©**:

```rust
#[tauri::command]
pub async fn add_file_from_path(
    path: String,
    is_pro_mode: bool,
    state: State<'_, FileListState>,
) -> Result<(), String> {
    let mut file_list = state.0.lock().await;

    // Free Î™®Îìú ÌååÏùº Ï†úÌïú (5Í∞ú)
    if !is_pro_mode && file_list.len() >= 5 {
        return Err("Free mode is limited to 5 files. Upgrade to Pro Mode for unlimited files.".to_string());
    }

    // ÌååÏùº Ï∂îÍ∞Ä Î°úÏßÅ
    file_list.push(/* ... */);
    Ok(())
}
```

**ReactÏóêÏÑú Ìò∏Ï∂ú Ïãú Pro ÏÉÅÌÉú Ï†ÑÎã¨**:

```typescript
const { isPro } = useProModeStore();

await invoke("add_file_from_path", {
  path: "/path/to/file.jpg",
  isProMode: isPro,  // Pro ÏÉÅÌÉú Ï†ÑÎã¨
});
```

---

## 3. macOS App Store ÏΩîÎìú ÏÑúÎ™Ö

### 3.1 Ïù∏Ï¶ùÏÑú Ï§ÄÎπÑ

**ÌïÑÏöîÌïú Ïù∏Ï¶ùÏÑú** (Apple Developer Í≥ÑÏ†ï ÌïÑÏöî, $99/year):

1. **Developer ID Application** (Í∞úÎ∞ú Î∞è ÌÖåÏä§Ìä∏)
2. **3rd Party Mac Developer Application** (App Store Ï†úÏ∂úÏö©)
3. **3rd Party Mac Developer Installer** (PKG ÏÑúÎ™ÖÏö©)

**Ïù∏Ï¶ùÏÑú Îã§Ïö¥Î°úÎìú**:
1. Apple Developer ‚Üí Certificates ‚Üí "+" Î≤ÑÌäº
2. "3rd Party Mac Developer Application" ÏÑ†ÌÉù
3. CSR ÌååÏùº ÏóÖÎ°úÎìú (ÌÇ§Ï≤¥Ïù∏ Ï†ëÍ∑º ‚Üí Ïù∏Ï¶ùÏÑú ÏßÄÏõê ‚Üí Ïù∏Ï¶ù Í∏∞Í¥ÄÏóêÏÑú Ïù∏Ï¶ùÏÑú ÏöîÏ≤≠)
4. Îã§Ïö¥Î°úÎìú ÌõÑ ÎçîÎ∏îÌÅ¥Î¶≠ÌïòÏó¨ ÌÇ§Ï≤¥Ïù∏Ïóê ÏÑ§Ïπò

### 3.2 Provisioning Profile ÏÉùÏÑ±

**App Store ConnectÏóêÏÑú**:
1. App Îì±Î°ù (Bundle ID: `com.yourcompany.yourapp`)
2. Certificates, Identifiers & Profiles ‚Üí Profiles ‚Üí "+"
3. "Mac App Store" ÏÑ†ÌÉù
4. App ID ÏÑ†ÌÉù ‚Üí Ïù∏Ï¶ùÏÑú ÏÑ†ÌÉù ‚Üí ÌîÑÎ°úÌïÑ Îã§Ïö¥Î°úÎìú
5. `apple_profile/` ÎîîÎ†âÌÜ†Î¶¨Ïóê Ï†ÄÏû•

### 3.3 Entitlements ÏÑ§Ï†ï

**Î©îÏù∏ Ïï±** (`src-tauri/Entitlements.plist`):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- App Sandbox ÌôúÏÑ±Ìôî (App Store ÌïÑÏàò) -->
    <key>com.apple.security.app-sandbox</key>
    <true/>

    <!-- ÌååÏùº ÏãúÏä§ÌÖú Ï†ëÍ∑º -->
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>

    <!-- ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ëÍ∑º (URLÏóêÏÑú Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú) -->
    <key>com.apple.security.network.client</key>
    <true/>

    <!-- IAP ÌôúÏÑ±Ìôî -->
    <key>com.apple.security.app-sandbox</key>
    <true/>
</dict>
</plist>
```

**Sidecar** (`src-tauri/SidecarEntitlements.plist`):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- App Sandbox ÌôúÏÑ±Ìôî -->
    <key>com.apple.security.app-sandbox</key>
    <true/>

    <!-- ÏÉÅÏÜçÎêú ÌååÏùº Ï†ëÍ∑º Í∂åÌïú -->
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>
</dict>
</plist>
```

### 3.4 ÏΩîÎìú ÏÑúÎ™Ö Ïä§ÌÅ¨Î¶ΩÌä∏

**Ï†ÑÏ≤¥ ÏÑúÎ™Ö ÌîÑÎ°úÏÑ∏Ïä§** (`scripts/create-pkg.sh`):

```bash
#!/bin/bash
set -e

APP_NAME="AnyImage - Batch Converter"
APP_PATH="src-tauri/target/aarch64-apple-darwin/release/bundle/macos/${APP_NAME}.app"
PKG_PATH="src-tauri/target/aarch64-apple-darwin/release/bundle/macos/${APP_NAME}.pkg"
ENTITLEMENTS="src-tauri/Entitlements.plist"
SIDECAR_ENTITLEMENTS="src-tauri/SidecarEntitlements.plist"

# ÏÑúÎ™Ö ID (KeychainÏóê ÏÑ§ÏπòÎêú Ïù∏Ï¶ùÏÑú)
SIGNING_IDENTITY="3rd Party Mac Developer Application: Your Name (TEAM_ID)"
INSTALLER_IDENTITY="3rd Party Mac Developer Installer: Your Name (TEAM_ID)"

echo "üîê Code signing .app bundle..."

# 1. Sidecar Î®ºÏ†Ä ÏÑúÎ™Ö (Ï§ëÏöî!)
echo "  ‚Üí Signing heic-sidecar..."
if [ -f "${APP_PATH}/Contents/MacOS/heic-sidecar" ]; then
  codesign --force --sign "${SIGNING_IDENTITY}" \
    --entitlements "${SIDECAR_ENTITLEMENTS}" \
    --options runtime \
    "${APP_PATH}/Contents/MacOS/heic-sidecar"
fi

# 2. Î©îÏù∏ Ïï± ÏÑúÎ™Ö (--deep ÏÇ¨Ïö© Ïïà Ìï®!)
echo "  ‚Üí Signing main app..."
codesign --force --sign "${SIGNING_IDENTITY}" \
  --entitlements "${ENTITLEMENTS}" \
  --options runtime \
  "${APP_PATH}"

# 3. ÏÑúÎ™Ö Í≤ÄÏ¶ù
echo "‚úÖ Verifying signature..."
codesign --verify --verbose "${APP_PATH}"
spctl --assess --verbose "${APP_PATH}"

# 4. PKG ÏÉùÏÑ± Î∞è ÏÑúÎ™Ö
echo "üì¶ Creating .pkg installer..."
productbuild \
  --component "${APP_PATH}" /Applications \
  --sign "${INSTALLER_IDENTITY}" \
  "${PKG_PATH}"

echo "‚úÖ PKG created: ${PKG_PATH}"

# 5. PKG ÏÑúÎ™Ö Í≤ÄÏ¶ù
echo "üîç Verifying pkg signature..."
pkgutil --check-signature "${PKG_PATH}"
```

**ÏÑúÎ™Ö ÏàúÏÑú (Ï§ëÏöî!)**:
1. ‚úÖ **Sidecar Î®ºÏ†Ä ÏÑúÎ™Ö** (Í∞ÄÏû• ÏïàÏ™ΩÎ∂ÄÌÑ∞)
2. ‚úÖ **Î©îÏù∏ Ïï± ÏÑúÎ™Ö** (`--deep` ÏÇ¨Ïö© Ïïà Ìï® - sidecar ÏÑúÎ™Ö Î≥¥Ï°¥)
3. ‚úÖ **PKG ÏÑúÎ™Ö**

**Í≤ÄÏ¶ù Î™ÖÎ†πÏñ¥**:

```bash
# Ïï± ÏÑúÎ™Ö ÌôïÏù∏
codesign -dv --verbose=4 "${APP_PATH}"

# Sidecar ÏÑúÎ™Ö ÌôïÏù∏
codesign -d --entitlements :- "${APP_PATH}/Contents/MacOS/heic-sidecar" | grep app-sandbox

# PKG ÏÑúÎ™Ö ÌôïÏù∏
pkgutil --check-signature "${PKG_PATH}"

# Gatekeeper ÌèâÍ∞Ä
spctl --assess --verbose "${APP_PATH}"
```

### 3.5 App Store ÏóÖÎ°úÎìú

**Transporter ÏÇ¨Ïö©**:

1. **PKG ÏÉùÏÑ±**: `bun run appstore` (ÏûêÎèô ÎπåÎìú + ÏÑúÎ™Ö)
2. **Transporter Ïó¥Í∏∞**: `/Applications/Transporter.app`
3. **PKG ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠**: `AnyImage - Batch Converter.pkg`
4. **Upload** ÌÅ¥Î¶≠
5. **App Store Connect**ÏóêÏÑú ÎπåÎìú ÌôïÏù∏ (10-30Î∂Ñ ÏÜåÏöî)

**Ï£ºÏùòÏÇ¨Ìï≠**:
- ‚ö†Ô∏è Bundle IDÍ∞Ä App Store ConnectÏôÄ **Ï†ïÌôïÌûà ÏùºÏπò**Ìï¥Ïïº Ìï®
- ‚ö†Ô∏è Version/Build NumberÍ∞Ä Ïù¥Ï†Ñ ÎπåÎìúÎ≥¥Îã§ ÎÜíÏïÑÏïº Ìï®
- ‚ö†Ô∏è Provisioning ProfileÏù¥ ÏµúÏã† ÏÉÅÌÉúÏó¨Ïïº Ìï®

---

## 4. ÎîîÏûêÏù∏ ÏãúÏä§ÌÖú Ìå®ÌÑ¥

### 4.1 Tailwind CSS v4 + oklch Ïª¨Îü¨

**ÌÖåÎßà ÏÑ§Ï†ï** (`src/index.css`):

```css
@import "tailwindcss";

/* Îã§ÌÅ¨ Î™®Îìú Ïª§Ïä§ÌÖÄ variant */
@custom-variant dark (&:is(.dark *));

/* ÌÖåÎßà Î≥ÄÏàò Ï†ïÏùò */
@theme inline {
  --font-sans: "Lexend Deca", ui-sans-serif, system-ui, sans-serif;
  --radius: 0.625rem;
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  /* ... */
}

/* oklch Ïª¨Îü¨ (Light Î™®Îìú) */
:root {
  --background: oklch(1 0 0);          /* ÏàúÎ∞± */
  --foreground: oklch(0.145 0 0);      /* ÏßÑÌïú ÌöåÏÉâ */
  --primary: oklch(0.205 0 0);         /* Í±∞Ïùò Í≤ÄÏ†ï */
  --destructive: oklch(0.577 0.245 27.325);  /* Îπ®Í∞ï */
  /* ... */
}

/* Dark Î™®Îìú */
.dark {
  --background: oklch(20%, 0%, 89.876%);  /* ÏßÑÌïú ÌöåÏÉâ */
  --foreground: oklch(0.985 0 0);         /* Î∞ùÏùÄ ÌöåÏÉâ */
  --primary: oklch(0.922 0 0);            /* Í±∞Ïùò Ìù∞ÏÉâ */
  /* ... */
}
```

**oklch Ïª¨Îü¨Ïùò Ïû•Ï†ê**:
- ‚úÖ **ÏßÄÍ∞ÅÏ†Å Í∑†ÏùºÏÑ±**: Î∞ùÍ∏∞ Í∞íÏù¥ Ïã§Ï†ú Î≥¥Ïù¥Îäî Î∞ùÍ∏∞ÏôÄ ÏùºÏπò
- ‚úÖ **Îçî ÎÑìÏùÄ ÏÉâ Í≥µÍ∞Ñ**: RGBÎ≥¥Îã§ ÏÉùÏÉùÌïú ÏÉâÏÉÅ ÌëúÌòÑ
- ‚úÖ **Î≥¥Í∞Ñ ÌíàÏßà**: Í∑∏ÎùºÎç∞Ïù¥ÏÖòÏù¥ ÏûêÏó∞Ïä§Îü¨ÏõÄ

**ÌÖåÎßà Ï†ÑÌôò** (next-themes):

```typescript
import { ThemeProvider } from "next-themes";

function App() {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      {/* Ïï± Ïª¥Ìè¨ÎÑåÌä∏ */}
    </ThemeProvider>
  );
}
```

### 4.2 Radix UI + React 19 Ìå®ÌÑ¥

**‚ö†Ô∏è Ï§ëÏöî**: React 19Îäî ÏûêÎèô ref Ï†ÑÎã¨ ÏßÄÏõê ‚Üí `forwardRef` Î∂àÌïÑÏöî

**Button Ïª¥Ìè¨ÎÑåÌä∏** (`src/components/ui/button.tsx`):

```typescript
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

// CVAÎ°ú variant Ï†ïÏùò
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md transition-colors",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent",
        ghost: "hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

// React 19 Ìå®ÌÑ¥: forwardRef ÏóÜÏù¥ ÏùºÎ∞ò Ìï®Ïàò
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & VariantProps<typeof buttonVariants> & {
  asChild?: boolean;
}) {
  const Comp = asChild ? Slot : "button";
  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      data-slot="button"  // ÎîîÎ≤ÑÍπÖÏö©
      {...props}
    />
  );
}

export { Button, buttonVariants };
```

**ÏÇ¨Ïö© ÏòàÏãú**:

```typescript
import { Button } from "@/components/ui/button";

// Í∏∞Î≥∏ ÏÇ¨Ïö©
<Button variant="default">ÌÅ¥Î¶≠</Button>

// asChildÎ°ú Îã§ÌòïÏÑ± (Link Îì±)
<Button asChild>
  <a href="/pro">Pro Mode Íµ¨Îß§</a>
</Button>

// variant Ï°∞Ìï©
<Button variant="destructive" size="sm">ÏÇ≠Ï†ú</Button>
```

### 4.3 shadcn/ui Ïª¥Ìè¨ÎÑåÌä∏ ÏÑ§Ïπò

**‚ö†Ô∏è Ï£ºÏùò**: CLIÎäî React 18 Ìå®ÌÑ¥ÏúºÎ°ú ÏÉùÏÑ± ‚Üí **ÏàòÎèô Î≥ÄÌôò ÌïÑÏöî**

**ÏÑ§Ïπò**:

```bash
bunx --bun shadcn@latest add button
bunx --bun shadcn@latest add dialog
bunx --bun shadcn@latest add dropdown-menu
```

**React 19 Î≥ÄÌôò Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏**:

```typescript
// ‚ùå BEFORE (React 18 Ìå®ÌÑ¥)
import { forwardRef } from "react";

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, ...props }, ref) => {
    return <button ref={ref} className={className} {...props} />;
  }
);
Button.displayName = "Button";

// ‚úÖ AFTER (React 19 Ìå®ÌÑ¥)
function Button({ className, ...props }: ButtonProps) {
  return <button className={className} data-slot="button" {...props} />;
}
```

### 4.4 Biome ÏΩîÎìú Ïä§ÌÉÄÏùº

**ÏÑ§Ï†ï** (`biome.json`):

```json
{
  "formatter": {
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 80
  },
  "javascript": {
    "formatter": {
      "jsxQuoteStyle": "double",      // JSXÎäî ÌÅ∞Îî∞Ïò¥Ìëú
      "quoteStyle": "double",         // JSÎäî ÌÅ∞Îî∞Ïò¥Ìëú
      "semicolons": "always",         // ÏÑ∏ÎØ∏ÏΩúÎ°† ÌïÑÏàò
      "trailingCommas": "all",        // ÌõÑÌñâ ÏâºÌëú Ìï≠ÏÉÅ
      "bracketSpacing": false         // {foo} (Í≥µÎ∞± ÏóÜÏùå)
    }
  },
  "linter": {
    "rules": {
      "correctness": {
        "useExhaustiveDependencies": "off"  // React Compiler ÏÇ¨Ïö©
      }
    }
  }
}
```

**Î™ÖÎ†πÏñ¥**:

```bash
bun lint      # Î¶∞Ìä∏ Í≤ÄÏÇ¨
bun format    # Ìè¨Îß∑ Ï†ÅÏö©
bun check     # Î¶∞Ìä∏ + Ìè¨Îß∑ + ÏûêÎèô ÏàòÏ†ï
```

---

## 5. ÎπåÎìú Î∞è Î∞∞Ìè¨ ÏõåÌÅ¨ÌîåÎ°úÏö∞

### 5.1 Î≤ÑÏ†Ñ Í¥ÄÎ¶¨

**Î≤ÑÏ†Ñ ÎèôÍ∏∞Ìôî Ïä§ÌÅ¨Î¶ΩÌä∏** (`scripts/bump-version.sh`):

```bash
#!/bin/bash
set -e

# ÏÇ¨Ïö©Î≤ï: ./bump-version.sh [patch|minor|major]
BUMP_TYPE=${1:-patch}

# package.jsonÏóêÏÑú ÌòÑÏû¨ Î≤ÑÏ†Ñ ÏùΩÍ∏∞
CURRENT_VERSION=$(jq -r .version package.json)

# ÏÉà Î≤ÑÏ†Ñ Í≥ÑÏÇ∞
NEW_VERSION=$(node -e "
  const semver = require('semver');
  console.log(semver.inc('$CURRENT_VERSION', '$BUMP_TYPE'));
")

echo "üìå Bumping version: $CURRENT_VERSION ‚Üí $NEW_VERSION"

# 1. package.json ÏóÖÎç∞Ïù¥Ìä∏
jq ".version = \"$NEW_VERSION\"" package.json > package.json.tmp
mv package.json.tmp package.json

# 2. Cargo.toml ÏóÖÎç∞Ïù¥Ìä∏
sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" src-tauri/Cargo.toml

# 3. tauri.conf.json ÏóÖÎç∞Ïù¥Ìä∏
jq ".version = \"$NEW_VERSION\"" src-tauri/tauri.conf.json > tauri.conf.json.tmp
mv tauri.conf.json.tmp src-tauri/tauri.conf.json

echo "‚úÖ Version bumped to $NEW_VERSION"

# Git commit
git add package.json src-tauri/Cargo.toml src-tauri/tauri.conf.json
git commit -m "chore: bump version to $NEW_VERSION"
git tag "v$NEW_VERSION"

echo "üè∑Ô∏è Created tag: v$NEW_VERSION"
```

**ÏÇ¨Ïö©Î≤ï**:

```bash
bun run bump              # 0.1.27 ‚Üí 0.1.28 (patch)
bun run bump:minor        # 0.1.27 ‚Üí 0.2.0
bun run bump:major        # 0.1.27 ‚Üí 1.0.0

# Î≤ÑÏ†Ñ ÏóÖ + App Store ÎπåÎìú
bun run appstore:patch    # Bump patch + build
```

### 5.2 Ï†ÑÏ≤¥ ÎπåÎìú ÌååÏù¥ÌîÑÎùºÏù∏

**package.json scripts**:

```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsgo && vite build",
    "tauri": "tauri",
    "typecheck": "tsgo --noEmit",
    "lint": "biome lint .",
    "format": "biome format --write .",
    "check": "biome check --write .",

    "bump": "bash scripts/bump-version.sh patch",
    "bump:patch": "bash scripts/bump-version.sh patch",
    "bump:minor": "bash scripts/bump-version.sh minor",
    "bump:major": "bash scripts/bump-version.sh major",

    "appstore": "bun tauri build --bundles app --target aarch64-apple-darwin && bash scripts/create-pkg.sh",
    "appstore:patch": "bash scripts/bump-version.sh patch && bun run appstore",
    "appstore:minor": "bash scripts/bump-version.sh minor && bun run appstore",
    "appstore:major": "bash scripts/bump-version.sh major && bun run appstore"
  }
}
```

**ÎπåÎìú ÌùêÎ¶Ñ**:

```
1. Swift Sidecar ÎπåÎìú (scripts/build-sidecars.sh)
   ‚Üì
2. Swift Static Library ÎπåÎìú (scripts/build-iap-lib.sh)
   ‚Üì
3. Rust Î∞±ÏóîÎìú ÎπåÎìú (cargo build --release)
   ‚Üì
4. React ÌîÑÎ°†Ìä∏ÏóîÎìú ÎπåÎìú (tsgo && vite build)
   ‚Üì
5. Tauri Ïï± Î≤àÎì§ ÏÉùÏÑ± (.app)
   ‚Üì
6. ÏΩîÎìú ÏÑúÎ™Ö (scripts/create-pkg.sh)
   ‚Üì
7. PKG ÏÉùÏÑ± Î∞è ÏÑúÎ™Ö
   ‚Üì
8. TransporterÎ°ú App Store ÏóÖÎ°úÎìú
```

---

## 6. Ìä∏Îü¨Î∏îÏäàÌåÖ

### 6.1 Sidecar Í¥ÄÎ†® Ïò§Î•ò

**Î¨∏Ï†ú**: `Failed to create sidecar`

**ÏõêÏù∏**:
- Sidecar Î∞îÏù¥ÎÑàÎ¶¨Í∞Ä ÎπåÎìúÎêòÏßÄ ÏïäÏùå
- `tauri.conf.json`Ïóê Îì±Î°ù Ïïà Îê®
- ÌååÏùº Ïù¥Î¶Ñ Î∂àÏùºÏπò

**Ìï¥Í≤∞**:

```bash
# 1. Sidecar ÎπåÎìú ÌôïÏù∏
ls -la src-tauri/sidecars/

# 2. tauri.conf.json ÌôïÏù∏
cat src-tauri/tauri.conf.json | grep externalBin

# 3. ÏàòÎèô ÎπåÎìú
bash scripts/build-sidecars.sh
```

### 6.2 ÏΩîÎìú ÏÑúÎ™Ö Ïò§Î•ò

**Î¨∏Ï†ú**: `code object is not signed at all`

**ÏõêÏù∏**:
- Sidecar ÏÑúÎ™Ö ÎàÑÎùΩ
- ÏÑúÎ™Ö ÏàúÏÑú ÏûòÎ™ªÎê® (Î©îÏù∏ Ïï± Î®ºÏ†Ä ÏÑúÎ™Ö ‚Üí sidecar ÏÑúÎ™Ö ÎçÆÏñ¥ÏîÄ)

**Ìï¥Í≤∞**:

```bash
# ÏÑúÎ™Ö ÏàúÏÑú: Sidecar ‚Üí Main App ‚Üí PKG
codesign --force --sign "${SIGNING_IDENTITY}" \
  --entitlements SidecarEntitlements.plist \
  --options runtime \
  "${APP_PATH}/Contents/MacOS/heic-sidecar"

# --deep ÏÇ¨Ïö© Í∏àÏßÄ! (sidecar ÏÑúÎ™Ö ÏÜêÏã§)
codesign --force --sign "${SIGNING_IDENTITY}" \
  --entitlements Entitlements.plist \
  --options runtime \
  "${APP_PATH}"  # --deep ÏóÜÏù¥
```

### 6.3 App Sandbox Í∂åÌïú Ïò§Î•ò

**Î¨∏Ï†ú**: `operation not permitted` (ÌååÏùº Ï†ëÍ∑º)

**ÏõêÏù∏**:
- EntitlementsÏóê Í∂åÌïú ÎàÑÎùΩ
- User-selected filesÎßå Ï†ëÍ∑º Í∞ÄÎä•

**Ìï¥Í≤∞**:

```xml
<!-- Entitlements.plist -->
<key>com.apple.security.files.user-selected.read-write</key>
<true/>

<!-- ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌïú ÌååÏùºÎßå Ï†ëÍ∑º Í∞ÄÎä• -->
<!-- ÏûÑÏùò Í≤ΩÎ°ú Ï†ëÍ∑º Î∂àÍ∞Ä (/Users/xxx/Documents ÏßÅÏ†ë Ï†ëÍ∑º X) -->
```

### 6.4 IAP ÌÖåÏä§Ìä∏

**Sandbox ÌôòÍ≤Ω ÌÖåÏä§Ìä∏**:

1. **App Store Connect**: Sandbox Tester Í≥ÑÏ†ï ÏÉùÏÑ±
2. **macOS ÏÑ§Ï†ï**: Apple ID Î°úÍ∑∏ÏïÑÏõÉ (ÏãúÏä§ÌÖú ÌôòÍ≤ΩÏÑ§Ï†ï)
3. **Ïï± Ïã§Ìñâ**: Íµ¨Îß§ ÏãúÎèÑ ‚Üí Sandbox Í≥ÑÏ†ïÏúºÎ°ú Î°úÍ∑∏Ïù∏
4. **Íµ¨Îß§ ÏôÑÎ£å**: UserDefaults ÌôïÏù∏

**Ï£ºÏùò**:
- ‚ö†Ô∏è Sandbox Í≥ÑÏ†ïÏùÄ Ïã§Ï†ú Apple IDÏôÄ **Îã§Î•∏ Ïù¥Î©îÏùº** ÏÇ¨Ïö©
- ‚ö†Ô∏è Ïã§Ï†ú Í≤∞Ï†ú ÏóÜÏù¥ ÌÖåÏä§Ìä∏ Í∞ÄÎä•
- ‚ö†Ô∏è ÌîÑÎ°úÎçïÏÖò ÎπåÎìúÎßå ÌÖåÏä§Ìä∏ Í∞ÄÎä• (ÎîîÎ≤ÑÍ∑∏ ÎπåÎìú Î∂àÍ∞Ä)

---

## 7. Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

### ÏÉà ÌîÑÎ°úÏ†ùÌä∏ÏóêÏÑú Ïù¥ Ìå®ÌÑ¥ Ï†ÅÏö© Ïãú

**Swift Sidecar Ï∂îÍ∞Ä**:
- [ ] `src-tauri/sidecars/your-sidecar.swift` ÏÉùÏÑ±
- [ ] `scripts/build-sidecars.sh`Ïóê ÎπåÎìú Ïä§ÌÅ¨Î¶ΩÌä∏ Ï∂îÍ∞Ä
- [ ] `tauri.conf.json` ‚Üí `bundle.externalBin` Îì±Î°ù
- [ ] `scripts/create-pkg.sh`Ïóê ÏÑúÎ™Ö Ïä§ÌÅ¨Î¶ΩÌä∏ Ï∂îÍ∞Ä
- [ ] `src-tauri/SidecarEntitlements.plist` Í∂åÌïú ÏÑ§Ï†ï
- [ ] Rust ÌÜµÏã† Î†àÏù¥Ïñ¥ (`heic.rs` Ï∞∏Í≥†)

**Swift Static Library Ï∂îÍ∞Ä**:
- [ ] `src-tauri/swift/your-lib.swift` ÏÉùÏÑ± (`@_cdecl` Ìï®Ïàò)
- [ ] `scripts/build-iap-lib.sh` ÏûëÏÑ± (swiftc ‚Üí ar)
- [ ] `src-tauri/build.rs`Ïóê ÎßÅÌÅ¨ ÏÑ§Ï†ï
- [ ] `src-tauri/src/your-ffi.rs` FFI Î∞îÏù∏Îî©
- [ ] Framework ÎßÅÌÅ¨ (`-framework Foundation`)

**IAP ÌÜµÌï©**:
- [ ] App Store ConnectÏóêÏÑú Ï†úÌíà ID Îì±Î°ù
- [ ] Swift StoreKit 2 ÏΩîÎìú ÏûëÏÑ±
- [ ] Rust FFI Î∞îÏù∏Îî© (`iap.rs`)
- [ ] Zustand Store ÏÉùÏÑ± (`pro-mode-store.ts`)
- [ ] EntitlementsÏóê IAP Í∂åÌïú Ï∂îÍ∞Ä

**App Store Î∞∞Ìè¨**:
- [ ] Ïù∏Ï¶ùÏÑú Îã§Ïö¥Î°úÎìú (Application + Installer)
- [ ] Provisioning Profile ÏÉùÏÑ±
- [ ] `Entitlements.plist` ÏûëÏÑ±
- [ ] `SidecarEntitlements.plist` ÏûëÏÑ±
- [ ] `scripts/create-pkg.sh` ÏûëÏÑ±
- [ ] `scripts/bump-version.sh` ÏûëÏÑ±
- [ ] TransporterÎ°ú ÏóÖÎ°úÎìú ÌÖåÏä§Ìä∏

**ÎîîÏûêÏù∏ ÏãúÏä§ÌÖú**:
- [ ] Tailwind v4 + oklch Ïª¨Îü¨ ÏÑ§Ï†ï
- [ ] shadcn/ui Ïª¥Ìè¨ÎÑåÌä∏ ÏÑ§Ïπò ÌõÑ React 19 Î≥ÄÌôò
- [ ] Biome ÏÑ§Ï†ï (double quotes, no bracket spacing)
- [ ] next-themes Îã§ÌÅ¨Î™®Îìú ÏÑ§Ï†ï

---

## 8. Ï∞∏Í≥† ÏûêÎ£å

**Í≥µÏãù Î¨∏ÏÑú**:
- [Tauri v2 Î¨∏ÏÑú](https://v2.tauri.app/)
- [StoreKit 2 Í∞ÄÏù¥Îìú](https://developer.apple.com/storekit/)
- [App Store Ï†úÏ∂ú Í∞ÄÏù¥Îìú](https://developer.apple.com/app-store/submissions/)
- [Tailwind CSS v4](https://tailwindcss.com/blog/tailwindcss-v4-alpha)
- [Radix UI](https://www.radix-ui.com/)

**ÏΩîÎìú ÏÑúÎ™Ö**:
- [Code Signing Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/)
- [App Sandbox](https://developer.apple.com/documentation/security/app_sandbox)

**Ïª¨Îü¨ ÏãúÏä§ÌÖú**:
- [oklch ÏÜåÍ∞ú](https://oklch.com/)
- [oklch vs RGB](https://evilmartians.com/chronicles/oklch-in-css-why-quit-rgb-hsl)

---

**ÏûëÏÑ±Ïûê**: AnyImage Converter ÌîÑÎ°úÏ†ùÌä∏
**Î≤ÑÏ†Ñ**: 1.0.0
**ÏµúÏ¢Ö ÏàòÏ†ï**: 2025ÎÖÑ
